<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Трекер эмоций</title>
  <style>
    :root{
      --blue:#007AFF;
      --gray:#8E8E93;
      --red:#FF3B30;

      --bg:#f5f5f7;
      --shadow: 0 10px 26px rgba(0,0,0,.08);
      --r:14px;

      --gold:#FFD700; /* золото */
      --star-outline: rgba(0,0,0,.85); /* чёрный контур для пустых */
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      background:var(--bg);
      color:#111;
    }
    header{
      padding: 14px 16px;
      position:sticky; top:0;
      background: rgba(245,245,247,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0,0,0,.06);
      z-index:10;
    }
    h1{margin:0;font-size:18px}
    h2{margin:0;font-size:16px}
    .wrap{padding: 14px 16px 24px;}

    .screen{display:none}
    .screen.active{display:block}

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }
    .btn{
      border:0;
      border-radius: 12px;
      padding: 12px 14px;
      font-size: 14px;
      font-weight: 800;
      color:#fff;
      cursor:pointer;
      box-shadow: var(--shadow);
      transition: transform .12s ease;
      user-select:none;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{ background: var(--blue); }
    .btn.gray{ background: var(--gray); }
    .btn.danger{ background: var(--red); }

    /* ===== Экран 1: матрица 3x2 ===== */
    .matrixBlock{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap: 10px;
      margin-top: 12px;
    }
    @media (max-width: 520px){
      .matrixBlock{ grid-template-columns: 1fr; }
    }

    .groupColumn{
      border-radius: var(--r);
      overflow:hidden;
      box-shadow: var(--shadow);
      border: 2px solid transparent;
      user-select:none;
      cursor:pointer;
      transition: transform .12s ease, border-color .25s ease;
      background: #fff;
    }
    .groupColumn:active{ transform: scale(.99); }
    .groupColumn.selected{ border: 3px solid var(--blue); }

    .groupHeader{
      padding: 10px 10px;
      text-align:center;
      font-weight: 900;
      color: rgba(255,255,255,.95);
      letter-spacing: .2px;
    }

    .row{
      padding: 9px 10px;
      text-align:center;
      font-weight: 700;
      color: rgba(0,0,0,.78);
      border-top: 1px solid rgba(255,255,255,.65);

      /* ЭМОЦИИ НА ЭКРАНЕ 1 НЕКЛИКАБЕЛЬНЫ */
      pointer-events: none;
    }

    .card{
      background:#fff;
      border-radius: var(--r);
      box-shadow: var(--shadow);
      border: 1px solid rgba(0,0,0,.06);
      padding: 12px;
      margin-top: 12px;
    }
    .note{font-size:13px;color:rgba(0,0,0,.65);line-height:1.35}
    textarea{
      width:100%;
      min-height: 140px;
      resize: vertical;
      border-radius: 12px;
      border:1px solid rgba(0,0,0,.18);
      padding: 10px;
      font-size: 13px;
      line-height: 1.35;
    }

    /* ===== Экран 2 ===== */
    .emotionList{
      display:grid;
      gap: 10px;
      margin-top: 12px;
    }
    .emotionTile{
      border-radius: var(--r);
      padding: 12px 12px;
      box-shadow: var(--shadow);
      border: 2px solid transparent;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      user-select:none;
      cursor:pointer;
      transition: transform .12s ease, border-color .25s ease;
      color: rgba(255,255,255,.92);
      font-weight: 900;
    }
    .emotionTile:active{ transform: scale(.98); }
    .emotionTile.selected{ border: 3px solid var(--blue); }

    .emotionName{
      font-size: 15px;
      line-height: 1.2;
      word-break: break-word;
      font-weight: 900;
      text-shadow: 0 1px 2px rgba(0,0,0,.12);
    }

    /* звёзды: 5 отдельных символов */
    .stars{
      display:flex;
      gap: 2px;
      flex: 0 0 auto;
      align-items:center;
      text-shadow: 0 1px 2px rgba(0,0,0,.20);
    }
    .star{
      font-size: 18px;
      line-height: 1;
      letter-spacing: 0;
      user-select:none;
    }
    .star.filled{
      color: var(--gold);
    }
    .star.empty{
      color: rgba(255,255,255,.25); /* почти “без заливки” */
      /* тонкая “обводка” через тени */
      text-shadow:
        -0.6px 0 var(--star-outline),
         0.6px 0 var(--star-outline),
         0 -0.6px var(--star-outline),
         0  0.6px var(--star-outline);
    }
  </style>
</head>
<body>
<header>
  <h1>Трекер эмоций</h1>
</header>

<div class="wrap">
  <section id="screen-groups" class="screen active">
    <div class="controls" style="margin-top:0">
      <button class="btn gray" id="btnLoad">Загрузить файл эмоций</button>
    </div>

    <div id="topBlock" class="matrixBlock"></div>
    <div id="bottomBlock" class="matrixBlock"></div>

    <div class="controls">
      <button class="btn primary" id="btnCopy">Скопировать результат</button>
      <button class="btn danger" id="btnReset">Сбросить выбор</button>
    </div>

    <div id="fallbackBox" class="card" style="display:none;">
      <div style="font-weight:900;margin-bottom:8px;">Не удалось автоматически скопировать — скопируйте вручную:</div>
      <textarea id="fallbackText" readonly></textarea>
      <div class="controls">
        <button class="btn gray" id="btnSelectText">Выделить текст</button>
        <button class="btn gray" id="btnHideFallback">Скрыть</button>
      </div>
    </div>

    <div class="card">
      <div class="note">
        Приложение пытается загрузить файл <b>emotions.txt</b> рядом с index.html.
        Если вы открываете локально (file://) и загрузка блокируется — нажмите “Загрузить файл эмоций” и выберите ваш TXT.
      </div>
    </div>

    <input id="fileInput" type="file" accept=".txt,text/plain" style="display:none;" />
  </section>

  <section id="screen-emotions" class="screen">
    <div class="controls" style="margin-top:0">
      <button class="btn gray" id="btnBack">← К группам</button>
    </div>
    <h2 id="groupTitle" style="margin-top:12px;"></h2>
    <div id="emotionList" class="emotionList"></div>
  </section>
</div>

<script>
  const GROUP_COLORS = {
    grief: "#5C4033",
    fear:  "#8B7F7A",
    hate:  "#8B6080",
    anger: "#DB5C70",
    joy:   "#FFB430",
    love:  "#5AD418",
  };

  const TOP_ORDER = ["fear", "hate", "anger"];
  const BOTTOM_ORDER = ["grief", "joy", "love"];

  const NAME_TO_ID = {
    "Страх": "fear",
    "Ненависть": "hate",
    "Гнев": "anger",
    "Горе": "grief",
    "Радость": "joy",
    "Любовь": "love",
  };

  let groups = [];
  const selected = Object.create(null);
  let currentGroupId = null;

  const screenGroups = document.getElementById("screen-groups");
  const screenEmotions = document.getElementById("screen-emotions");
  const topBlock = document.getElementById("topBlock");
  const bottomBlock = document.getElementById("bottomBlock");
  const groupTitle = document.getElementById("groupTitle");
  const emotionList = document.getElementById("emotionList");

  const btnBack = document.getElementById("btnBack");
  const btnCopy = document.getElementById("btnCopy");
  const btnReset = document.getElementById("btnReset");
  const btnLoad = document.getElementById("btnLoad");

  const fallbackBox = document.getElementById("fallbackBox");
  const fallbackText = document.getElementById("fallbackText");
  const btnSelectText = document.getElementById("btnSelectText");
  const btnHideFallback = document.getElementById("btnHideFallback");

  const fileInput = document.getElementById("fileInput");

  const pad2 = (n) => String(n).padStart(2, "0");
  function formatDateTime(d){
    return `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.${d.getFullYear()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  }

  function groupSelectedCount(groupId){
    const m = selected[groupId];
    return m ? Object.keys(m).length : 0;
  }

  function lightenColorHex(hex, alpha){
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function parseEmotionsTxt(txt){
    const lines = String(txt || "")
      .replace(/\r/g, "")
      .split("\n")
      .map(s => s.trim())
      .filter(s => s.length > 0);

    const result = [];
    let current = null;

    for(const line of lines){
      const isHeader = /:\s*$/.test(line);
      if(isHeader){
        const groupName = line.replace(/:\s*$/, "").trim();
        const id = NAME_TO_ID[groupName] || null;
        current = { id, name: groupName, emotions: [] };
        result.push(current);
      }else{
        if(!current) continue;
        current.emotions.push(line);
      }
    }

    const normalized = result
      .map(g => ({
        id: g.id,
        name: g.name,
        emotions: Array.from(new Set(g.emotions)).filter(Boolean)
      }))
      .filter(g => g.id);

    const byId = Object.create(null);
    for(const g of normalized){
      byId[g.id] = { ...g, color: GROUP_COLORS[g.id] || "#444" };
    }

    return [
      {id:"fear",  name:"Страх"},
      {id:"hate",  name:"Ненависть"},
      {id:"anger", name:"Гнев"},
      {id:"grief", name:"Горе"},
      {id:"joy",   name:"Радость"},
      {id:"love",  name:"Любовь"},
    ].map(x => byId[x.id] ? byId[x.id] : ({...x, emotions:[], color: GROUP_COLORS[x.id]}));
  }

  async function loadFromDefaultTxt(){
    const r = await fetch("emotions.txt", { cache: "no-store" });
    if(!r.ok) throw new Error("Не удалось загрузить emotions.txt");
    return parseEmotionsTxt(await r.text());
  }

  function loadFromUserTxtFile(file){
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        try{ resolve(parseEmotionsTxt(String(reader.result || ""))); }
        catch(e){ reject(new Error("Не удалось разобрать файл: " + e.message)); }
      };
      reader.onerror = () => reject(new Error("Ошибка чтения файла"));
      reader.readAsText(file, "utf-8");
    });
  }

  function renderMatrix(){
    topBlock.innerHTML = "";
    bottomBlock.innerHTML = "";

    const byId = Object.create(null);
    for(const g of groups) byId[g.id] = g;

    for(const id of TOP_ORDER){
      if(byId[id]) topBlock.appendChild(renderGroupColumn(byId[id]));
    }
    for(const id of BOTTOM_ORDER){
      if(byId[id]) bottomBlock.appendChild(renderGroupColumn(byId[id]));
    }
  }

  function renderGroupColumn(g){
    const count = groupSelectedCount(g.id);

    const col = document.createElement("div");
    col.className = "groupColumn" + (count > 0 ? " selected" : "");
    col.addEventListener("click", () => openGroup(g.id));

    const header = document.createElement("div");
    header.className = "groupHeader";
    header.style.background = g.color;
    header.textContent = g.name;
    col.appendChild(header);

    const base1 = lightenColorHex(g.color, 0.22);
    const base2 = lightenColorHex(g.color, 0.16);

    (g.emotions || []).forEach((e, idx) => {
      const row = document.createElement("div");
      row.className = "row";
      row.textContent = e;
      row.style.background = (idx % 2 === 0) ? base1 : base2;
      col.appendChild(row);
    });

    return col;
  }

  function renderStars(intensity){
    const wrap = document.createElement("div");
    wrap.className = "stars";
    for(let i=1;i<=5;i++){
      const s = document.createElement("span");
      const filled = i <= intensity;
      s.className = "star " + (filled ? "filled" : "empty");
      s.textContent = filled ? "★" : "☆";
      wrap.appendChild(s);
    }
    return wrap;
  }

  function renderEmotions(groupId){
    const g = groups.find(x => x.id === groupId);
    groupTitle.textContent = g ? `Группа: ${g.name}` : "Группа";
    emotionList.innerHTML = "";
    if(!g) return;

    for(const e of g.emotions){
      const intensity = (selected[groupId] && selected[groupId][e]) ? selected[groupId][e] : 0;

      const tile = document.createElement("div");
      tile.className = "emotionTile" + (intensity > 0 ? " selected" : "");
      tile.style.background = g.color;

      const name = document.createElement("div");
      name.className = "emotionName";
      name.textContent = e;

      const starsNode = renderStars(intensity);

      tile.appendChild(name);
      tile.appendChild(starsNode);

      tile.addEventListener("click", () => {
        const next = intensity >= 5 ? 0 : intensity + 1;
        if(next === 0){
          if(selected[groupId]) delete selected[groupId][e];
          if(selected[groupId] && Object.keys(selected[groupId]).length === 0) delete selected[groupId];
        }else{
          if(!selected[groupId]) selected[groupId] = Object.create(null);
          selected[groupId][e] = next;
        }
        renderEmotions(groupId);
      });

      emotionList.appendChild(tile);
    }
  }

  function openGroup(groupId){
    currentGroupId = groupId;
    screenGroups.classList.remove("active");
    screenEmotions.classList.add("active");
    renderEmotions(groupId);
  }

  function backToMatrix(){
    currentGroupId = null;
    screenEmotions.classList.remove("active");
    screenGroups.classList.add("active");
    renderMatrix();
  }

  function exportStarsText(i){
    return "★".repeat(i) + "☆".repeat(5 - i);
  }

  function buildExportText(){
    const lines = [formatDateTime(new Date())];
    const order = [...TOP_ORDER, ...BOTTOM_ORDER];

    for(const id of order){
      const g = groups.find(x => x.id === id);
      if(!g) continue;
      const m = selected[id];
      if(!m) continue;

      for(const e of g.emotions){
        const i = m[e];
        if(!i) continue;
        lines.push(`${g.name}: ${e} ${exportStarsText(i)}`);
      }
    }
    return lines.join("\n");
  }

  async function copyResult(){
    fallbackBox.style.display = "none";
    if(Object.keys(selected).length === 0){
      alert("Не выбрано ни одной эмоции.");
      return;
    }
    const text = buildExportText();
    try{
      await navigator.clipboard.writeText(text);
      alert("Скопировано в буфер обмена.");
    }catch(err){
      fallbackText.value = text;
      fallbackBox.style.display = "block";
      fallbackBox.scrollIntoView({behavior:"smooth", block:"start"});
    }
  }

  function resetAll(){
    if(!confirm("Сбросить все выбранные эмоции?")) return;
    for(const k of Object.keys(selected)) delete selected[k];
    fallbackBox.style.display = "none";
    if(screenEmotions.classList.contains("active") && currentGroupId){
      renderEmotions(currentGroupId);
    }else{
      renderMatrix();
    }
  }

  btnBack.addEventListener("click", backToMatrix);
  btnCopy.addEventListener("click", copyResult);
  btnReset.addEventListener("click", resetAll);

  btnSelectText.addEventListener("click", () => { fallbackText.focus(); fallbackText.select(); });
  btnHideFallback.addEventListener("click", () => { fallbackBox.style.display = "none"; });

  btnLoad.addEventListener("click", () => fileInput.click());
  fileInput.addEventListener("change", async () => {
    const file = fileInput.files && fileInput.files[0];
    if(!file) return;
    try{
      groups = await loadFromUserTxtFile(file);
      backToMatrix();
    }catch(e){
      alert(e.message);
    }finally{
      fileInput.value = "";
    }
  });

  (async function init(){
    try{
      groups = await loadFromDefaultTxt();
    }catch(e){
      groups = [
        {id:"fear",  name:"Страх",     emotions:[], color: GROUP_COLORS.fear},
        {id:"hate",  name:"Ненависть", emotions:[], color: GROUP_COLORS.hate},
        {id:"anger", name:"Гнев",      emotions:[], color: GROUP_COLORS.anger},
        {id:"grief", name:"Горе",      emotions:[], color: GROUP_COLORS.grief},
        {id:"joy",   name:"Радость",   emotions:[], color: GROUP_COLORS.joy},
        {id:"love",  name:"Любовь",    emotions:[], color: GROUP_COLORS.love},
      ];
    }
    renderMatrix();
  })();
</script>
</body>
</html>
