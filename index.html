<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Трекер эмоций</title>
  <style>
    :root{
      --blue:#007AFF;
      --red:#FF3B30;

      --bg:#f5f5f7;
      --shadow: 0 10px 26px rgba(0,0,0,.08);
      --r:14px;

      --gold:#FFD700;          /* золото для выбранных */
      --star-outline:#111111;  /* тонкий чёрный контур для пустых */
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      background:var(--bg);
      color:#111;
    }
    header{
      padding: 10px 12px;
      position:sticky; top:0;
      background: rgba(245,245,247,.92);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0,0,0,.06);
      z-index:10;
    }
    h1{margin:0;font-size:16px}

    .wrap{padding: 10px 12px 18px;}

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .btn{
      border:0;
      border-radius: 12px;
      padding: 11px 12px;
      font-size: 14px;
      font-weight: 800;
      color:#fff;
      cursor:pointer;
      box-shadow: var(--shadow);
      transition: transform .12s ease;
      user-select:none;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{ background: var(--blue); }
    .btn.danger{ background: var(--red); }

    /* ===== Экран: матрица 3x2 (всегда), чтобы на телефоне были видны ВСЕ группы сразу ===== */
    .matrixBlock{
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
      margin-top: 10px;
    }

    .groupColumn{
      border-radius: var(--r);
      overflow:hidden;
      box-shadow: var(--shadow);
      border: 2px solid transparent;
      background: #fff;
      transition: border-color .25s ease;
    }
    .groupColumn.selected{ border: 3px solid var(--blue); }

    .groupHeader{
      padding: 8px 8px;
      text-align:center;
      font-weight: 900;
      color: rgba(255,255,255,.95);
      letter-spacing: .2px;
      font-size: 14px;
    }

    .row{
      padding: 7px 8px;
      font-weight: 800;
      color: rgba(0,0,0,.82);
      border-top: 1px solid rgba(255,255,255,.65);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 6px;

      cursor:pointer;
      user-select:none;
      transition: transform .12s ease;
    }
    .row:active{ transform: scale(.99); }

    .rowName{
      font-size: 12.5px;
      line-height: 1.15;
      word-break: break-word;
    }

    /* звёзды: 5 отдельных символов */
    .stars{
      display:flex;
      gap: 1px;
      flex: 0 0 auto;
      align-items:center;
    }
    .star{
      font-size: 14px;
      line-height: 1;
      user-select:none;
    }
    .star.filled{
      color: var(--gold);
      text-shadow: 0 1px 1px rgba(0,0,0,.15);
    }
    .star.empty{
      color: rgba(255,255,255,.10); /* почти “без заливки” */
      text-shadow:
        -0.5px 0 var(--star-outline),
         0.5px 0 var(--star-outline),
         0 -0.5px var(--star-outline),
         0  0.5px var(--star-outline);
    }

    /* fallback для ручного копирования */
    .card{
      background:#fff;
      border-radius: var(--r);
      box-shadow: var(--shadow);
      border: 1px solid rgba(0,0,0,.06);
      padding: 12px;
      margin-top: 12px;
    }
    textarea{
      width:100%;
      min-height: 140px;
      resize: vertical;
      border-radius: 12px;
      border:1px solid rgba(0,0,0,.18);
      padding: 10px;
      font-size: 13px;
      line-height: 1.35;
    }

    /* Чуть плотнее на очень узких экранах */
    @media (max-width: 390px){
      .wrap{padding: 8px 10px 16px;}
      .matrixBlock{gap: 6px;}
      .groupHeader{font-size: 13px; padding: 7px 6px;}
      .row{padding: 6px 6px;}
      .rowName{font-size: 12px;}
      .star{font-size: 13px;}
    }
  </style>
</head>
<body>
<header>
  <h1>Трекер эмоций</h1>
</header>

<div class="wrap">
  <!-- Матрица: выбор делается прямо на этом экране -->
  <div id="block1" class="matrixBlock"></div>
  <div id="block2" class="matrixBlock"></div>

  <div class="controls">
    <button class="btn primary" id="btnCopy">Скопировать результат</button>
    <button class="btn danger" id="btnReset">Сбросить выбор</button>
  </div>

  <div id="fallbackBox" class="card" style="display:none;">
    <div style="font-weight:900;margin-bottom:8px;">Скопируйте вручную:</div>
    <textarea id="fallbackText" readonly></textarea>
    <div class="controls">
      <button class="btn primary" id="btnSelectText">Выделить текст</button>
      <button class="btn danger" id="btnHideFallback">Скрыть</button>
    </div>
  </div>
</div>

<script>
  // Цвета (как в ТЗ)
  const GROUP_COLORS = {
    grief: "#5C4033",
    fear:  "#8B7F7A",
    hate:  "#8B6080",
    anger: "#DB5C70",
    joy:   "#FFB430",
    love:  "#5AD418",
  };

  // Требуемый порядок групп: горе, страх, ненависть, гнев, радость, любовь
  // Разбивка по строкам 3+3, чтобы ВСЕ группы были на экране 1 сразу.
  const ROW1 = ["grief", "fear", "hate"];
  const ROW2 = ["anger", "joy", "love"];

  // Сопоставление русских названий групп -> id
  const NAME_TO_ID = {
    "Горе": "grief",
    "Страх": "fear",
    "Ненависть": "hate",
    "Гнев": "anger",
    "Радость": "joy",
    "Любовь": "love",
  };

  let groups = []; // [{id,name,color,emotions:[...]}]
  const selected = Object.create(null); // selected[groupId][emotion]=1..5

  const block1 = document.getElementById("block1");
  const block2 = document.getElementById("block2");
  const btnCopy = document.getElementById("btnCopy");
  const btnReset = document.getElementById("btnReset");

  const fallbackBox = document.getElementById("fallbackBox");
  const fallbackText = document.getElementById("fallbackText");
  const btnSelectText = document.getElementById("btnSelectText");
  const btnHideFallback = document.getElementById("btnHideFallback");

  // Utils
  const pad2 = (n) => String(n).padStart(2, "0");
  function formatDateTime(d){
    return `${pad2(d.getDate())}.${pad2(d.getMonth()+1)}.${d.getFullYear()} ${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
  }

  function lightenColorHex(hex, alpha){
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${alpha})`;
  }

  function groupSelectedCount(groupId){
    const m = selected[groupId];
    return m ? Object.keys(m).length : 0;
  }

  function parseEmotionsTxt(txt){
    const lines = String(txt || "")
      .replace(/\r/g, "")
      .split("\n")
      .map(s => s.trim())
      .filter(s => s.length > 0);

    const result = [];
    let current = null;

    for(const line of lines){
      const isHeader = /:\s*$/.test(line);
      if(isHeader){
        const groupName = line.replace(/:\s*$/, "").trim();
        const id = NAME_TO_ID[groupName] || null;
        current = { id, name: groupName, emotions: [] };
        result.push(current);
      }else{
        if(!current) continue;
        current.emotions.push(line);
      }
    }

    const normalized = result
      .map(g => ({
        id: g.id,
        name: g.name,
        emotions: Array.from(new Set(g.emotions)).filter(Boolean)
      }))
      .filter(g => g.id);

    const byId = Object.create(null);
    for(const g of normalized){
      byId[g.id] = { ...g, color: GROUP_COLORS[g.id] || "#444" };
    }

    // вернуть все 6 групп в порядке (на случай, если в txt какой-то блок пустой)
    return ["grief","fear","hate","anger","joy","love"]
      .map(id => byId[id] ? byId[id] : ({ id, name: Object.keys(NAME_TO_ID).find(k => NAME_TO_ID[k]===id) || id, emotions:[], color: GROUP_COLORS[id] }));
  }

  async function loadFromDefaultTxt(){
    const r = await fetch("emotions.txt", { cache: "no-store" });
    if(!r.ok) throw new Error("Не удалось загрузить emotions.txt");
    return parseEmotionsTxt(await r.text());
  }

  function renderStars(intensity){
    const wrap = document.createElement("div");
    wrap.className = "stars";
    for(let i=1;i<=5;i++){
      const s = document.createElement("span");
      const filled = i <= intensity;
      s.className = "star " + (filled ? "filled" : "empty");
      s.textContent = filled ? "★" : "☆";
      wrap.appendChild(s);
    }
    return wrap;
  }

  function updateIntensity(groupId, emotion, currentIntensity){
    const next = currentIntensity >= 5 ? 0 : currentIntensity + 1;
    if(next === 0){
      if(selected[groupId]) delete selected[groupId][emotion];
      if(selected[groupId] && Object.keys(selected[groupId]).length === 0) delete selected[groupId];
    }else{
      if(!selected[groupId]) selected[groupId] = Object.create(null);
      selected[groupId][emotion] = next;
    }
  }

  function renderMatrix(){
    block1.innerHTML = "";
    block2.innerHTML = "";

    const byId = Object.create(null);
    for(const g of groups) byId[g.id] = g;

    for(const id of ROW1){
      if(byId[id]) block1.appendChild(renderGroupColumn(byId[id]));
    }
    for(const id of ROW2){
      if(byId[id]) block2.appendChild(renderGroupColumn(byId[id]));
    }
  }

  function renderGroupColumn(g){
    const col = document.createElement("div");
    col.className = "groupColumn" + (groupSelectedCount(g.id) > 0 ? " selected" : "");

    const header = document.createElement("div");
    header.className = "groupHeader";
    header.style.background = g.color;
    header.textContent = g.name;
    col.appendChild(header);

    const base1 = lightenColorHex(g.color, 0.22);
    const base2 = lightenColorHex(g.color, 0.16);

    (g.emotions || []).forEach((emotion, idx) => {
      const intensity = (selected[g.id] && selected[g.id][emotion]) ? selected[g.id][emotion] : 0;

      const row = document.createElement("div");
      row.className = "row";
      row.style.background = (idx % 2 === 0) ? base1 : base2;

      const name = document.createElement("div");
      name.className = "rowName";
      name.textContent = emotion;

      const stars = renderStars(intensity);

      row.appendChild(name);
      row.appendChild(stars);

      row.addEventListener("click", (ev) => {
        ev.preventDefault();
        updateIntensity(g.id, emotion, intensity);
        renderMatrix(); // быстрое переотрисовывание, чтобы обновить звёзды + рамку группы
      });

      col.appendChild(row);
    });

    return col;
  }

  function exportStarsText(i){
    return "★".repeat(i) + "☆".repeat(5 - i);
  }

  function buildExportText(){
    const lines = [formatDateTime(new Date())];
    const order = ["grief","fear","hate","anger","joy","love"];

    for(const id of order){
      const g = groups.find(x => x.id === id);
      if(!g) continue;
      const m = selected[id];
      if(!m) continue;

      for(const e of g.emotions){
        const i = m[e];
        if(!i) continue;
        lines.push(`${g.name}: ${e} ${exportStarsText(i)}`);
      }
    }
    return lines.join("\n");
  }

  async function copyResult(){
    fallbackBox.style.display = "none";
    if(Object.keys(selected).length === 0){
      alert("Не выбрано ни одной эмоции.");
      return;
    }
    const text = buildExportText();
    try{
      await navigator.clipboard.writeText(text);
      alert("Скопировано в буфер обмена.");
    }catch(err){
      fallbackText.value = text;
      fallbackBox.style.display = "block";
      fallbackBox.scrollIntoView({behavior:"smooth", block:"start"});
    }
  }

  function resetAll(){
    if(!confirm("Сбросить все выбранные эмоции?")) return;
    for(const k of Object.keys(selected)) delete selected[k];
    fallbackBox.style.display = "none";
    renderMatrix();
  }

  btnCopy.addEventListener("click", copyResult);
  btnReset.addEventListener("click", resetAll);

  btnSelectText.addEventListener("click", () => { fallbackText.focus(); fallbackText.select(); });
  btnHideFallback.addEventListener("click", () => { fallbackBox.style.display = "none"; });

  (async function init(){
    try{
      groups = await loadFromDefaultTxt();
    }catch(e){
      // если файл не загрузился, показываем пустую матрицу (но на GitHub Pages fetch работает)
      groups = ["grief","fear","hate","anger","joy","love"].map(id => ({
        id,
        name: Object.keys(NAME_TO_ID).find(k => NAME_TO_ID[k]===id) || id,
        emotions: [],
        color: GROUP_COLORS[id]
      }));
    }
    renderMatrix();
  })();
</script>
</body>
</html>
